# Initialization

The LBRY daemon must be running before using the majority of these tools.
This can be done by launching the full LBRY Desktop application,
or by starting the console `lbrynet` program.
```
lbrynet start
```

Then in a Python terminal, or in a Python script, import `lbrtytools`
or the individual methods.
```py
import lbrytools as lbryt
```

Or
```py
from lbrytools import download_single
from lbrytools import ch_download_latest
from lbrytools import ch_download_latest_multi
from lbrytools import print_summary
from lbrytools import redownload_latest
from lbrytools import download_claims
from lbrytools import delete_single
from lbrytools import measure_usage
from lbrytools import cleanup_space
from lbrytools import remove_media
```

# Download

Define the download directory.
```py
ddir = "/opt/download"
```

Download a single item from the LBRY network by URI (`'canonical_url'`)
or `'claim_id'`.
Place the file in a subdirectory in the download directory.
```py
d = lbryt.download_single(uri="RoboCopOS#c", ddir=ddir, own_dir=True)
d = lbryt.download_single(cid="c8e8bb0029f6cb7d1b4d287b6e040339aa8b7f3e", ddir=ddir, own_dir=True)
```

# Multiple downloads

Download the latest claims from a single channel.
The channel may be specified fully, with the prefix `@` and characters after
`#` or `:`, or partially, without them.
Full names are necessary to distinguish two channels with the same base name.
```py
c = lbryt.ch_download_latest(channel="@lbry", number=3, ddir=ddir)
```

Various claims from many channels can be downloaded at the same time.
Define a list where each element is a list of two elements; the first item
is the name of the channel, and the second is a number indicating how
many items will be downloaded from that channel.
If the number is missing it will use the default value (2).
```py
channels = [
    ["@BrodieRobertson#5", 2],
#    ["@Lunduke:e", 4],
    ["@Odysee#8", 2],
#    ["@MoneroTalk:8", 1],
    ["@samtime#1", 3],
    ["@Veritasium:f", 2]
]

ch = lbryt.ch_download_latest_multi(channels=channels, ddir=ddir)
```

By using the `number` parameter, the individual numbers in `channels`
are overriden.
For exampe, download the 4 newest claims from each channel.
```py
ch = lbryt.ch_download_latest_multi(channels=channels, ddir=ddir, number=4)
```

Another way of specifying the list of channels is as a simple list of strings.
Again, `number` controls the number of downloads for all channels.
For example, download the latest claim for each channel in the list.
```py
channels = [
    "BrodieRobertson",
    "Lunduke",
    "MoneroTalk"
]

c = lbryt.ch_download_latest_multi(channels=channels, ddir=ddir, number=1)
```

If the list of channels is large, it is better to randomize it
so that we can start downloading from an arbitrary channel, and not
always from the first one in the list.
```py
c = lbryt.ch_download_latest_multi(channels=channels, ddir=ddir, rand=True)
```

# Printing

Print a list of claims that have been downloaded partially or fully
in chronological order, by `item['metadata']['release_time']`.
Older claims appear first.
Certain items don't have `'release time'`, so for these
the `'timestamp'` is used.

Specify a filename to print to that file, otherwise it will print to
the terminal. Optionally add the date to the filename.
```py
p = lbryt.print_summary()
p = lbryt.print_summary(file="/opt/summary.txt")
p = lbryt.print_summary(file="/opt/summary.txt", date=True)
```

Various options control which claims are actually printed.
Print all files,
or only those which have incomplete blobs,
or only those which have all their blobs,
or only those for which the full media file (mp4, mp3, mkv, etc.) exists,
or only those for which the media file is missing.
```py
p = lbryt.print_summary(show="all")
p = lbryt.print_summary(show="incomplete")
p = lbryt.print_summary(show="full")
p = lbryt.print_summary(show="media")
p = lbryt.print_summary(show="missing")
```

Normally only items that have all blobs also have a media file; however,
if the claim is currently being downloaded a partial media file may be present.

Various options control what type of information is printed, including title,
type, download path, claim id, number of blobs, name of channel,
and name of claim.
Printing the channel's name is slow as it needs to perform an additional search
for the channel.
```py
p = lbryt.print_summary(title=True, typ=False, path=False,
                        cid=True, blobs=True, ch=False,
                        name=True)
```
 
Print only a range of items, or only the claims by a specific channel
(it implies `ch=True` and is slow).
```py
p = lbryt.print_summary(start=20, end=40)
p = lbryt.print_summary(channel="Veritasium")
```

# Download from file

Download claims from a comma-separated values (CSV) file that lists
one claim per row, with the `'claim_id'` in one column.
This type of file can be generated by `print_summary`.
```py
p = lbryt.print_summary(file="summary.txt")

q = lbryt.download_claims(ddir=ddir, own_dir=True, file="summary.txt")
```

The list of claims can be limited by a range of indices.
```py
q = lbryt.download_claims(ddir=ddir, start=20, end=80, file="summary.txt")
```

Sharing a list of claims in this way allows different systems to download,
and seed the same content.

# Re-download

Re-downloading a claim that was previously downloaded will get the missing
blobs of that claim in order to create the media file. If the blobs are
complete but the media file is missing, this file will simply be recreated
in the download directory.

Attempt to re-download the latest (newest) items that were already downloaded.
This can be done to resume the download of claims that for some reason
were not fully downloaded.
```py
r = lbryt.redownload_latest(number=10, ddir=ddir, own_dir=True)
```

If the list of claims is shuffled, then we can re-download random claims,
not necessarily the latest ones.
```py
r = lbryt.redownload_latest(number=20, ddir=ddir, own_dir=True, rand=True)
```

----

With `download_claims` if the `file` argument is omitted, it will try to
redownload all claims previously downloaded.
```py
q = lbryt.download_claims(ddir=ddir)
```

# Delete

Delete a single downloaded item by URI or `'claim_id'`.
Choose to delete the media file (mp4, mp3, mkv, etc.), the blobs, or both.
```py
s = lbryt.delete_single(cid="099ace3145fba6bef6b529bcf03efcc0eb8ebfc9", what="media")
s = lbryt.delete_single(uri="if-samsung-made-a-macbook", what="blobs")
s = lbryt.delete_single(uri="RoboCopOS", what="both")
```

As long as the blobs are present, the content can be seeded to the network,
and the full file can be restored.
That is, while the blobs exist the file is not completely deleted.

# Measure disk usage

Measure the space that is being used by downloaded content and their blobs;
`main_dir` is assumed to be the hard disk or partition that holds both
the downloaded files and the blobs.

In a typical Linux installation both directories are in the same partition
```
ddir  = /home/user/Downloads
blobs = /home/user/.local/share/lbry/lbrynet/blobfiles
```
therefore
```py
main_dir = "/home/user"
```

If the blobfiles directory is symbolically linked to another partition,
and the download directory is also specified in this partition,
then `main_dir` should be specified accordingly.
```
ddir  = /opt/download
blobs = /home/user/.local/share/lbry/lbrynet/blobfiles -> /opt/lbryblobfiles/
```
therefore
```py
main_dir = "/opt"
```

Then `size` is the space in gigabytes (GB) in `main_dir` dedicated
to the media and blobs; `percent` is how much it will fill up before space
needs to be freed.
```py
m = lbryt.measure_usage(main_dir=main_dir, size=1000, percent=90)
m = lbryt.measure_usage(main_dir=main_dir, size=1000, percent=90, bar=False)
```

# Clean up space

Free space by deleting older media files when 90% of `size` is full.
```py
n = lbryt.cleanup_space(main_dir=main_dir, size=1000, percent=90, what="media")
```

We can choose to delete media files, blobs, or both.
While the blobs exist, the media file can be seeded and recreated.
More space is freed by deleting both media and blobs.
```py
n = lbryt.cleanup_space(main_dir=main_dir, what="media")
n = lbryt.cleanup_space(main_dir=main_dir, what="blobs")
n = lbryt.cleanup_space(main_dir=main_dir, what="both")
```

Free space but avoid deleting the content from certain channels.
This is slow as it needs to perform an additional search for the channel.
```py
never_delete = [
    "@lbry",
    "@Odysee",
    "@samtime",
    "@RobBraxmanTech"
]

n = lbryt.cleanup_space(main_dir=main_dir, size=2000, never_delete=never_delete)
```

----

Remove all downloaded media files (mp4, mp3, mkv, etc.) and leave only
the binary blobs.
This is useful for systems that will only seed the downloaded content,
as only the blobs are necessary in this case.
```py
k = lbryt.remove_media()
```

The `never_delete` list can be used, although for headless systems that will
only seed it should be avoided.
```py
k = lbryt.remove_media(never_delete=never_delete)
```

# Server

Internally, the functions communicate with the LBRY daemon through
a local JSON-RCP server.
By default, the server is listening on `http://localhost:5279`.

Most functions accept an optional parameter to specify the server address,
although this rarely needs to be provided.
```py
server = "http://localhost:5279"

lbryt.download_single(..., server=server)
lbryt.ch_download_latest(..., server=server)
lbryt.ch_download_latest_multi(..., server=server)
lbryt.print_summary(..., server=server)
lbryt.redownload_latest(..., server=server)
lbryt.download_claims(..., server=server)
lbryt.delete_single(..., server=server)
lbryt.measure_usage(...)
lbryt.cleanup_space(..., server=server)
lbryt.remove_media(..., server=server)
```
